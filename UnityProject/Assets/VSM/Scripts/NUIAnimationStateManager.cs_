using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using SA.Common.CustomDataStructures;
using TT.GER.Logic.SharedLogic.Modules.DataInfo;
using UnityEngine.Experimental.Director;

[System.Serializable]
public class NUIAnimationStateManager : MonoBehaviour
{
    [SerializeField] public List<StateManagerInfo> StateInfos;
    [SerializeField] public string BaseSMClassName;

    public Animator AnimatorRef;

    private bool _initialized;
    private bool _isReady;

    //private bool _forceStateAfterDisable = true;

    private Dictionary<string, CachedSetupData> CachedSetupAggregatedData;
    private class CachedSetupData
    {
        public int ShortStateNameHash;
        public string StateName;
        public bool ForceUpdate;

        public CachedSetupData(int shortStateNameHash, string stateName, bool forceUpdate)
        {
            ShortStateNameHash = shortStateNameHash;
            StateName = stateName;
            ForceUpdate = forceUpdate;
        }
    }

    /// <summary>
    /// Switch one of GameObjects' State Managers to specified state.
    /// </summary>
    /// <param name="stateManager">State Manager is an animation layer name in Attached Animator>Animation controller. Layer has to be named by convension "SM_NameOfStateManager"</param>
    /// <param name="shortStateNameHash">Hash of the state in State Manager animation layer, created by Animator.StringToHash()</param>
    /// <param name="stateName">Short name of the state in State Manager animation layer</param>
    /// <param name="forceUpdate">Set to "true" to apply state even if you are alredy in that state</param>
    public void SwitchState(string stateManager, int shortStateNameHash, string stateName = "", bool forceUpdate = false)
    {
        Init();

        if (!AnimatorRef.enabled || !gameObject.activeInHierarchy)
        {
            CacheCall(stateManager, shortStateNameHash, stateName, forceUpdate);

            return;
        }

        var stateManagerInfo = StateInfos.FirstOrDefault(x => x.Name == stateManager);
        int index = stateManagerInfo.AvaliableStates.IndexOf(stateName);
        int currentIndex = stateManagerInfo.AvaliableStates.IndexOf(stateManagerInfo.CurrentState);
        bool isInCurrentState = AnimatorRef.GetCurrentAnimatorStateInfo(AnimatorRef.GetLayerIndex(stateManager)).shortNameHash == shortStateNameHash;
        bool isOnWrongTime = Math.Abs(stateManagerInfo.AvaliableStateTimings[index] - stateManagerInfo.AvaliableStateTimings[currentIndex]) > TT.Common.Math.EPSILON;
        if (isInCurrentState && !forceUpdate && !isOnWrongTime) return;

        StateManagerInfo currentStateInfo = StateInfos.First(x => x.Name == stateManager);

        var stateManagerLayerIndex = StateInfos.First(x => x.Name == stateManager).Index;
        if (stateManagerLayerIndex < 0)
        {
            Debug.LogError("NUIAnimationStateManager Error: Can't find stateManager with name '" + stateManager + "' in "+AnimatorRef.runtimeAnimatorController.name+" of "+gameObject.name);
            return;
        }

        if (!Application.isPlaying) return;

        if (!AnimatorRef.HasState(stateManagerLayerIndex, shortStateNameHash))
        {
            Debug.LogError("NUIAnimationStateManager Error: Can't find state with name '" + stateName + "' in '"+ stateManager + "', in " + AnimatorRef.runtimeAnimatorController.name + " of " + gameObject.name);
            return;
        }

        int animationStateInternalIndex = currentStateInfo.AvaliableStates.IndexOf(stateName);

        if (currentStateInfo.IsUsingStateTags)
        {
            RuntimeAnimatorController controller = AnimatorRef.runtimeAnimatorController;
            int stateClipIndex = controller.animationClips.Select(x => x.name).ToList().IndexOf(currentStateInfo.MainClipName);
            if (stateClipIndex < 0)
            {
                Debug.LogWarning("NUIAnimationStateManager Error: Cant find animation clip '"+ currentStateInfo.MainClipName + "' for StateManager '"+ stateManager+"'");
                return;
            }

            AnimatorRef.SetFloat("Speed_" + currentStateInfo.Name, 1);

            AnimatorRef.Play(shortStateNameHash, stateManagerLayerIndex, currentStateInfo.AvaliableStateTimings[animationStateInternalIndex]);
            AnimatorRef.Update(Time.deltaTime);

            AnimatorRef.SetFloat("Speed_" + currentStateInfo.Name, 0);
            
            if (gameObject.GetComponent<UIWidget>() != null)
            {
                gameObject.GetComponent<UIWidget>().SetDirty();
            }
        }
        else
        {
            AnimatorRef.Play(shortStateNameHash, stateManagerLayerIndex);
        }
        
        currentStateInfo.CurrentStateHash = shortStateNameHash;
        currentStateInfo.CurrentState = stateName;
        currentStateInfo.HasBeenSet = true;
    }

    private void CacheCall(string stateManager, int shortStateNameHash, string stateName, bool forceUpdate = false)
    {
        if (CachedSetupAggregatedData == null)
            CachedSetupAggregatedData = new Dictionary<string, CachedSetupData>();

        CachedSetupData cachedSetupData;
        if (CachedSetupAggregatedData.ContainsKey(stateManager))
        {
            cachedSetupData = CachedSetupAggregatedData[stateManager];
            cachedSetupData.ShortStateNameHash = shortStateNameHash;
            cachedSetupData.StateName = stateName;
            cachedSetupData.ForceUpdate = forceUpdate;
        }
        else
        {
            cachedSetupData = new CachedSetupData(shortStateNameHash, stateName, forceUpdate);
            CachedSetupAggregatedData.Add(stateManager, cachedSetupData);
        }
    }

    /// <summary>
    /// Switch one of GameObjects' State Managers to specified state.
    /// </summary>
    /// <param name="stateManager">State Manager is an animation layer name in Attached Animator>Animation controller. Layer has to be named by convension "SM_NameOfStateManager"</param>
    /// <param name="stateName">Name of the state in State Manager animation layer</param>
    /// <param name="forceUpdate">Set to "true" to apply state even if you are alredy in that state</param>
    public void SwitchState(string stateManager, string stateName, bool forceUpdate = false)
    {
        if (_isReady)
        {
            SwitchState(stateManager, Animator.StringToHash(stateName), stateName, forceUpdate);
        }
        else
        {
            if (CachedSetupAggregatedData != null)
                CachedSetupAggregatedData.Clear();

            CacheCall(stateManager, Animator.StringToHash(stateName), stateName, forceUpdate);
        }
    }

    private void Init()
    {
        if(_initialized) return;

        if (AnimatorRef == null) AnimatorRef = GetComponent<Animator>();
        if (AnimatorRef == null)
        {
            uLogger.Log("NUIAnimationStateManager Error: Can't find Animator component in " + gameObject.name, uLogLevel.Error);
            return;
        }
        
        for (int i = 0; i < AnimatorRef.layerCount; i++)
        {
            if(!AnimatorRef.GetLayerName(i).StartsWith("SM_")) continue;

            if (StateInfos == null)
            {
                StateInfos = new List<StateManagerInfo>();
            }

            if (StateInfos.Any(x => x.Name == AnimatorRef.GetLayerName(i)))
            {
                continue;
            }

            Debug.Log(AnimatorRef.GetLayerName(i)+" - GetCurrentAnimatorStateInfo = " + AnimatorRef.GetCurrentAnimatorStateInfo(i));

            StateManagerInfo stateInfo = new StateManagerInfo
            {
                DefaultStateHash = AnimatorRef.GetCurrentAnimatorStateInfo(i).shortNameHash
            };
            stateInfo.CurrentStateHash = stateInfo.DefaultStateHash;
            stateInfo.Name = AnimatorRef.GetLayerName(i);
            stateInfo.Index = i;
            StateInfos.Add(stateInfo);
        }
        

        _initialized = true;
    }

    private void ResetAllStateManagersToDefaultStates(bool dontResetIfAlreadySet = false)
    {
        foreach (var stateInfo in StateInfos)
        {
            if (!dontResetIfAlreadySet || !stateInfo.HasBeenSet)
                SwitchState(stateInfo.Name, stateInfo.DefaultState, true);
        }
    }

    private void OnEnable()
    {
        _isReady = true;
        Init();
        if (CachedSetupAggregatedData != null)
        {
            foreach (var cachedSetupDataPair in CachedSetupAggregatedData)
            {
                SwitchState(cachedSetupDataPair.Key,
                    cachedSetupDataPair.Value.ShortStateNameHash,
                    cachedSetupDataPair.Value.StateName,
                    cachedSetupDataPair.Value.ForceUpdate);
            }
            CachedSetupAggregatedData.Clear();
        }
    }

    private void OnDisable()
    {
        _isReady = false;
        foreach (var stateManager in StateInfos)
        {
            CacheCall(stateManager.Name, stateManager.CurrentStateHash, stateManager.CurrentState, true);
        }
        //_forceStateAfterDisable = true;

    }

    private void Start()
    {
		ResetAllStateManagersToDefaultStates(true);
    }

    [System.Serializable]
    public class StateManagerInfo
    {
        public string Name;
        public int Index;
        public int CurrentStateHash;
        public string CurrentState;
        public int DefaultStateHash;
        public string DefaultState;

        public bool IsUsingStateTags;
        public string MainClipName;
        [SerializeField]
        public List<string> AvaliableStates;
        [SerializeField]
        public float[] AvaliableStateTimings;

        [NonSerialized]
        public bool HasBeenSet = false;
    }

    private bool KvpContainsKey(string key, List<Kvp<string, StateManagerInfo>> source)
    {
        return source.Any(x => x.Key == key);
    }

    /// <summary>
    /// Used for animaon clip events. Each event is treated as Nnew state. This is optional mechanics
    /// </summary>
    /// <param name="stateName"></param>
    public void StateTag(string stateName) {}

}
